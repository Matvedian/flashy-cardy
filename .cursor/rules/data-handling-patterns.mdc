---
alwaysApply: true
---
});

export async function updateDeckAction(input: UpdateDeckInput) {
  // Validate in Server Action
  const validatedInput = UpdateDeckSchema.parse(input);
  
  // Pass clean, validated data to helper
  const updatedDeck = await updateDeck(
    validatedInput.deckId,
    validatedInput.title,
    validatedInput.description
  );
  
  if (updatedDeck) {
    revalidatePath("/dashboard");
    return { success: true, deck: updatedDeck };
  }
  
  return { success: false, error: "Failed to update deck" };
}

// ❌ WRONG - Validation in query helper
export async function updateDeck(input: any) {
  // Query helpers should not handle validation
  const validatedInput = UpdateDeckSchema.parse(input);
}
```

### 6. Benefits of Centralized Query Helpers

**Why this pattern is mandatory:**

1. **Security**: Authentication and authorization are handled once in the helper
2. **Consistency**: All database operations follow the same patterns
3. **Maintainability**: Business logic is centralized and reusable
4. **Type Safety**: Query results are properly typed across the application
5. **Data Integrity**: Related operations (like updating card counts) are handled automatically
6. **Testing**: Database operations can be mocked/tested in isolation
7. **Performance**: Query optimization happens in one place

### 7. Adding New Database Operations

When adding new functionality:

1. **Add helper function to [src/db/queries.ts](mdc:src/db/queries.ts)** first
2. **Follow established naming**: `getUserX`, `createX`, `updateX`, `deleteX`
3. **Include authentication checks** using Clerk's `auth()`
4. **Verify ownership** for resource-specific operations
5. **Handle related updates** (e.g., card counts, timestamps)
6. **Use proper return types** from schema definitions
7. **Add JSDoc comments** explaining the function's purpose

```typescript
/**
 * Create a new study session for a deck owned by the current user
 */
export async function createStudySession(
  deckId: string, 
  duration: number, 
  cardsStudied: number, 
  correctAnswers: number
): Promise<StudySession> {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error("Authentication required to create study session");
  }

  // Verify user owns the deck
  const deck = await getDeckById(deckId);
  if (!deck) {
    throw new Error("Deck not found or access denied");
  }

  const [newSession] = await db
    .insert(studySessionsTable)
    .values({
      deckId,
      userId, // Always include userId for new records
      duration,
      cardsStudied,
      correctAnswers,
    })
    .returning();
  
  return newSession;
}
```

## File Organization

- **Query Helpers**: [src/db/queries.ts](mdc:src/db/queries.ts) - All database operations
- **Server Actions**: Create in `src/actions/` directory (e.g., `deck-actions.ts`)
- **Zod Schemas**: Define alongside Server Actions
- **Server Components**: Import and call query helpers directly
- **Database Schema**: [src/db/schema.ts](mdc:src/db/schema.ts) - Table definitions only

## Security Integration

All query helpers automatically integrate with Clerk authentication:

- Every helper calls `auth()` and verifies `userId`
- Read operations return empty arrays/null for unauthenticated users
- Write operations throw errors for unauthenticated users
- Resource access verifies ownership through helper functions
- User data is always filtered by `userId`

## Checklist for All Data Operations

- [ ] **Query Helper**: Is there a helper function in [src/db/queries.ts](mdc:src/db/queries.ts)?
- [ ] **Server Component**: Does it call the query helper directly?
- [ ] **Server Action**: Does it call the query helper (not direct DB access)?
- [ ] **Validation**: Is Zod validation in Server Action only?
- [ ] **Authentication**: Does helper verify `userId` from `auth()`?
- [ ] **Authorization**: Does helper check resource ownership?
- [ ] **Revalidation**: Does Server Action call `revalidatePath()`?

## Forbidden Patterns

**NEVER DO:**

- ❌ Direct database access outside of [src/db/queries.ts](mdc:src/db/queries.ts)
- ❌ Data fetching in Client Components (`useEffect`, `fetch`, `useState`)
- ❌ API routes for CRUD operations (use Server Actions + query helpers)
- ❌ Skip query helpers for "performance" or "simplicity"
- ❌ Duplicate database logic across Server Actions
- ❌ Authentication checks outside of query helpers
- ❌ Direct imports of `db`, `schema` outside of queries.ts

## Migration Path

If you find direct database access in the codebase:

1. **Create helper function** in [src/db/queries.ts](mdc:src/db/queries.ts) with proper auth/validation
2. **Replace direct access** with helper function call
3. **Test the migration** to ensure same functionality
4. **Remove unused imports** (`db`, schema tables) from migrated files

**Remember**: The `db/queries` directory is the single source of truth for all database operations. Every piece of data that enters or leaves the database must go through these centralized helper functions to ensure security, consistency, and maintainability.
